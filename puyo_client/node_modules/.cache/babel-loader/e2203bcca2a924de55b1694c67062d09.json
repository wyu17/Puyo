{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/home/wyu/Desktop/puyo/puyo/src/hooks/useStage.js\",\n    _s = $RefreshSig$();\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { createStage, STAGE_HEIGHT, STAGE_WIDTH } from '../gameHelpers';\nimport Cell from '../components/Cell';\nimport { randomBlock } from '../block';\nimport { emptyBlock } from '../block';\nimport { BLOCK } from '../block';\nimport { PUYO_COL, PUYO_ROW } from '../gameHelpers';\nexport const useStage = (currentBlock, resetCurrentBlock) => {\n  _s();\n\n  // Initial State\n  const [stage, setStage] = useState(Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill( /*#__PURE__*/_jsxDEV(Cell, {\n    type: emptyBlock().color\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 11,\n    columnNumber: 106\n  }, this))));\n  const updateStage = useCallback((currentBlock, prevStage, prevPosition, prevPosition2) => {\n    let newStage = createStage();\n\n    for (let i = 0; i < STAGE_HEIGHT; i++) {\n      for (let j = 0; j < STAGE_WIDTH; j++) {\n        newStage[i][j] = prevStage[i][j];\n      }\n    }\n\n    ;\n\n    if (prevPosition && prevPosition2) {\n      newStage[prevPosition.y][prevPosition.x] = /*#__PURE__*/_jsxDEV(Cell, {\n        type: emptyBlock().color\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 56\n      }, this);\n      newStage[prevPosition2.y][prevPosition2.x] = /*#__PURE__*/_jsxDEV(Cell, {\n        type: emptyBlock().color\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 22,\n        columnNumber: 58\n      }, this);\n    } // Will need to implement some form of keeping blocks saved\n    // to:do guarantee different colours between the top and bottom\n\n\n    let temp = currentBlock.dir > 1 ? currentBlock.color1 : currentBlock.color;\n    let tempcolor1 = currentBlock.dir > 1 ? currentBlock.color : currentBlock.color1;\n    newStage[currentBlock.position.y][currentBlock.position.x] = /*#__PURE__*/_jsxDEV(Cell, {\n      type: temp\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 70\n    }, this);\n    newStage[currentBlock.position2.y][currentBlock.position2.x] = /*#__PURE__*/_jsxDEV(Cell, {\n      type: tempcolor1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 72\n    }, this);\n    return newStage;\n  }, []);\n  const resetStage = useCallback((color, color1) => {\n    let newStage = createStage();\n    newStage[PUYO_ROW][PUYO_COL] = /*#__PURE__*/_jsxDEV(Cell, {\n      type: color\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 40\n    }, this);\n    newStage[PUYO_ROW + 1][PUYO_COL] = /*#__PURE__*/_jsxDEV(Cell, {\n      type: color1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 44\n    }, this);\n    return newStage;\n  }, []);\n\n  const registerCollision = (block, stage, color, color1) => {\n    let newStage = createStage();\n\n    for (let i = 0; i < STAGE_HEIGHT; i++) {\n      for (let j = 0; j < STAGE_WIDTH; j++) {\n        newStage[i][j] = stage[i][j];\n      }\n    }\n\n    newStage[PUYO_ROW][PUYO_COL] = /*#__PURE__*/_jsxDEV(Cell, {\n      type: color\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 47,\n      columnNumber: 40\n    }, this);\n    newStage[PUYO_ROW + 1][PUYO_COL] = /*#__PURE__*/_jsxDEV(Cell, {\n      type: color1\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 48,\n      columnNumber: 44\n    }, this);\n    return newStage;\n  };\n\n  return [stage, setStage, resetStage, updateStage, registerCollision];\n};\n\n_s(useStage, \"WbTWgvDvhWWCSb0Hq+Yz2DIwdyA=\");","map":{"version":3,"sources":["/home/wyu/Desktop/puyo/puyo/src/hooks/useStage.js"],"names":["useState","useEffect","useCallback","createStage","STAGE_HEIGHT","STAGE_WIDTH","Cell","randomBlock","emptyBlock","BLOCK","PUYO_COL","PUYO_ROW","useStage","currentBlock","resetCurrentBlock","stage","setStage","Array","from","fill","color","updateStage","prevStage","prevPosition","prevPosition2","newStage","i","j","y","x","temp","dir","color1","tempcolor1","position","position2","resetStage","registerCollision","block"],"mappings":"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","sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { createStage, STAGE_HEIGHT, STAGE_WIDTH } from '../gameHelpers';\nimport Cell from '../components/Cell';\nimport { randomBlock } from '../block';\nimport { emptyBlock } from '../block';\nimport { BLOCK } from '../block';\nimport { PUYO_COL, PUYO_ROW } from '../gameHelpers';\n\nexport const useStage = (currentBlock, resetCurrentBlock) => {\n    // Initial State\n    const [stage, setStage] = useState(Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill(<Cell type = {emptyBlock().color}/>)));\n\n    const updateStage = useCallback ((currentBlock, prevStage, prevPosition, prevPosition2) => {\n        let newStage = createStage();\n        for (let i = 0; i < STAGE_HEIGHT; i++) {\n            for (let j = 0; j < STAGE_WIDTH; j++) {\n                newStage[i][j] = prevStage[i][j];\n            }\n        };\n        if (prevPosition && prevPosition2 ) {\n            newStage[prevPosition.y][prevPosition.x] = <Cell type = {emptyBlock().color}/>;\n            newStage[prevPosition2.y][prevPosition2.x] = <Cell type = {emptyBlock().color}/>;\n        }\n        // Will need to implement some form of keeping blocks saved\n        // to:do guarantee different colours between the top and bottom\n        let temp = (currentBlock.dir > 1) ? currentBlock.color1 : currentBlock.color;\n        let tempcolor1 =  (currentBlock.dir > 1) ? currentBlock.color : currentBlock.color1;\n        newStage[currentBlock.position.y][currentBlock.position.x] = <Cell type = {temp}/>;\n        newStage[currentBlock.position2.y][currentBlock.position2.x] = <Cell type = {tempcolor1}/>;\n        return newStage;\n    }, []);\n\n    const resetStage = useCallback((color, color1) => {\n        let newStage = createStage();\n        newStage[PUYO_ROW][PUYO_COL] = <Cell type = {color}/>;\n        newStage[PUYO_ROW + 1][PUYO_COL] = <Cell type = {color1}/>;\n        return newStage;\n    }, []);\n\n    const registerCollision = (block, stage, color, color1) => {\n        let newStage = createStage();\n        for (let i = 0; i < STAGE_HEIGHT; i++) {\n            for (let j = 0; j < STAGE_WIDTH; j++) {\n                newStage[i][j] = stage[i][j];\n            }\n        }\n        newStage[PUYO_ROW][PUYO_COL] = <Cell type = {color}/>;\n        newStage[PUYO_ROW + 1][PUYO_COL] = <Cell type = {color1}/>;\n        return newStage;\n    }\n\n    return [stage, setStage, resetStage, updateStage, registerCollision];\n}"]},"metadata":{},"sourceType":"module"}